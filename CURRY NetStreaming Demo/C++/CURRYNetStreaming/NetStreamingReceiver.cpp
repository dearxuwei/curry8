/****************************************************************************
 * (c) Neuroscan $Date: 2020-05-14 15:50:41 +0200 (Thu, 14 May 2020) $
 *
 * $Revision: 23937 $
 * $Author: tech $
 **************************************************(header generated by SVN)*/
#include "stdafx.h"
/****************************************************************************/
static char* REV = "$Revision: 23937 $";
static char* DAT = "$Date: 2020-05-14 15:50:41 +0200 (Thu, 14 May 2020) $";
/*************************************************(strings generated by SVN)*/
// $NoKeywords: $

#include "NetStreamingReceiver.h"

#include <atlsocket.h>
#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

void get_clock ( double *tw)
{	
	if ( !tw )
	{
		return;
	}
	
	LARGE_INTEGER start, freq;

	// Get ticks-per-second of the performance counter.
	// Get ticks since system start of the performance counter.
	// this has a resolution of 0.8us
	if ( QueryPerformanceFrequency ( &freq ) && QueryPerformanceCounter ( &start ) )
	{
		*tw	= (double)start.QuadPart / (double)freq.QuadPart;
	}
}

CNetStreamingReceiver::CNetStreamingReceiver(IAddLogLine* pAddLogLine, ICtrlWaveforms* pCtrlWavelforms) : m_Thread(this)
{
	m_nSocketType				= SOCK_STREAM; //TCP

	m_bDoConnect				= false;
	m_usNetstreamPort			= 0;
	m_sNetstreamClientServerIP	= "";

	m_bClientInited				= false;
	m_SocketClient				= 0;
	m_nNetStreamingVersion		= -1;
	m_bBasicInfoValid			= false;
	m_nServerAmpStatus			= -1;
	m_pChannelInfoList			= NULL;
	m_nChannelInfoListSize		= 0;

	m_pAddLogLine				= pAddLogLine;
	m_pCtrlWaveforms			= pCtrlWavelforms;
}

CNetStreamingReceiver::~CNetStreamingReceiver(void)
{
	CloseClient();
	if (m_pChannelInfoList)
	{
		free((void*)m_pChannelInfoList);
	}
	m_nChannelInfoListSize = 0;
}

void CNetStreamingReceiver::AddLogLine(CString sLogLine, long nLogID)
{
	if (m_pAddLogLine)
	{
		m_pAddLogLine->AddLogLine(sLogLine, nLogID);
	}
}

bool CNetStreamingReceiver::IsConnected()						
{
	return m_bDoConnect;
}

void CNetStreamingReceiver::SetClient(bool bConnect, CString sIP, long nPort)
{
	m_bDoConnect				= bConnect;
	m_sNetstreamClientServerIP	= sIP;
	m_usNetstreamPort			= (unsigned short)nPort;
}

BOOL CNetStreamingReceiver::StartClientThread()
{
	CString sError;
	if (m_bClientInited || SUCCEEDED(OpenClient(&sError)))
	{
		m_Thread.Start();
		return TRUE;
	}

	AddLogLine(L"ERROR: Could connect to NetStreaming Server. " + sError);

	SetClient(false);

	return FALSE;
}

HRESULT CNetStreamingReceiver::OpenClient(CString* psError)
{
    WSADATA				wsaData	= {0,};
	long				nRetval;
	unsigned int		addr;
    struct sockaddr_in	server;
    struct hostent*		hp;
	char				wServerName[MAX_PATH];
	size_t				nSize;
	CString				sTmp;

	ASSERT(psError);

	AddLogLine(L"Starting up client...");

	CloseClient();

	if (m_sNetstreamClientServerIP.IsEmpty())
	{
		*psError = L"Client-Server IP is empty";
		return E_FAIL;
	}

	::wcstombs_s(&nSize, wServerName, _countof(wServerName), m_sNetstreamClientServerIP, _TRUNCATE);	//convert wchar_t to char

	if ((nRetval = WSAStartup(0x202, &wsaData)) != 0)
    {
		psError->Format(L"WSAStartup() failed with error %d", nRetval);
        WSACleanup();
        return E_FAIL;
    }
    else
	{
       TRACE("Client: WSAStartup() is OK.");
	}

    if (isalpha(wServerName[0]))				//attempt to detect if we should call gethostbyname() or gethostbyaddr()
    {   
        hp		= gethostbyname(wServerName);	//server address is a name
    }
    else
    { 
        addr	= inet_addr(wServerName);		//convert nnn.nnn address to a usable one
        hp		= gethostbyaddr((char *)&addr, 4, AF_INET);
    }

	if (hp == NULL )
    {
		psError->Format(L"cannot resolve Client-Server IP \"%S\": Error %d", wServerName, WSAGetLastError());
        WSACleanup();
		return E_FAIL;
    }
    else
	{
       AddLogLine(L"Client: gethostbyaddr() is OK.");
	}

	//copy the resolved information into the sockaddr_in structure
    memset(&server, 0, sizeof(server));
    memcpy(&(server.sin_addr), hp->h_addr, hp->h_length);
    server.sin_family	= hp->h_addrtype;
	server.sin_port		= htons(m_usNetstreamPort);

    m_SocketClient		= socket(AF_INET, m_nSocketType, IPPROTO_TCP); //open socket
    if (m_SocketClient < 0)
    {
		psError->Format(L"error opening socket: Error %d", WSAGetLastError());
        WSACleanup();
        return E_FAIL;
    }
    else
	{
       AddLogLine(L"Client: socket() is OK.");
	}

	//set socket to be a "no delay socket"
	int flag = 1;	//dummy flag
	if (setsockopt(m_SocketClient, IPPROTO_TCP, TCP_NODELAY, (char *)&flag, sizeof(int)) != 0)
	{
		psError->Format(L"error setting \"no delay socket\": Error %d", WSAGetLastError());
        WSACleanup();
        return E_FAIL;
	}

	sTmp.Format(L"Client connecting to server: %S.", hp->h_name);
	AddLogLine(sTmp);

	unsigned long unUnblocking = 1;
    ioctlsocket(m_SocketClient, FIONBIO, &unUnblocking); //put socket in non-blocking state

	//connect to server
	if (connect(m_SocketClient, (struct sockaddr*)&server, sizeof(server)) == SOCKET_ERROR)
    {
		//it is normal for non-blocking sockets to fail
		fd_set	socket_set	= {0,};
		timeval timer		= {0,};
  
		socket_set.fd_array[0]	= m_SocketClient;
		socket_set.fd_count		= 1;
		timer.tv_sec			= 2;	//set timeout to 2 sec
  
		//check if connection succeeded using select
		int ret = select(0, &socket_set, &socket_set, &socket_set, &timer);
  
		if (!ret || ret == SOCKET_ERROR) 
		{
			psError->Format(L"connect() failed: %d", WSAGetLastError());
			WSACleanup();
			return E_FAIL;
		}
		else
		{
			AddLogLine(L"Client: connect() is OK.");
		}
    }
    else
	{
       AddLogLine(L"Client: connect() is OK.");
	}

	unUnblocking = 0;
    ioctlsocket(m_SocketClient, FIONBIO, &unUnblocking); //put socket back in blocking state

	m_bClientInited = true;

	return S_OK;
}



HRESULT CNetStreamingReceiver::ListenClient(long nNumReceiveMessages,  std::atomic<bool>* pbActive)
{
	HRESULT	hr			= E_FAIL;
	char*	pcBuffer	= NULL;
	long	nSizeBuffer	= NETSTREAM_BUFFER_SIZE * SIZE_C;

	CAcqMessage message;

	if (!(pcBuffer = (char*)calloc(NETSTREAM_BUFFER_SIZE, SIZE_C)))
	{
		return E_OUTOFMEMORY;
	}

	AddLogLine(L"Connected to server.");
   
	//nNumReceiveMessages == -1 for infinite loop (from thread)
    while (nNumReceiveMessages == -1 || nNumReceiveMessages > 0)
    {
		if (!m_bClientInited)
		{
			hr = E_FAIL;
			break;
		}

		if (FAILED(hr = ReceiveNetStreamingMessage(m_SocketClient, &message)))
		{
			AddLogLine(L"ERROR: Receive data failed!");
			break;
		}
		
		if (FAILED(HandleMessage(&message, m_SocketClient)))
		{
			AddLogLine(L"ERROR: Handling Message!");
		}

		if (pbActive && !(*pbActive))
		{
			AddLogLine(L"ListenClient stop received.");
			break;
		}

		if (nNumReceiveMessages > 0)
		{
			--nNumReceiveMessages;
		}
    }

	return hr;
}

HRESULT CNetStreamingReceiver::CloseClient()
{
	if (m_bClientInited)
	{
		AddLogLine(L"Closing Client.");

		m_Thread.End();

		m_bClientInited			= false;
		closesocket(m_SocketClient);
		WSACleanup();

		m_bBasicInfoValid		= false;
		m_nChannelInfoListSize	= 0;
		if (m_pChannelInfoList)
		{
			free((void*)m_pChannelInfoList);
			m_pChannelInfoList = NULL;
		}
	}
	
	return S_OK;
}

//send header and data in two portions
HRESULT CNetStreamingReceiver::SendNetStreamingMessage(SOCKET socket, CAcqMessage* pMessage)
{
	CString s;

	if (!socket || !pMessage)
	{
		ASSERT(false);
		return E_INVALIDARG;
	}

	if (!pMessage->m_pBody)
	{
		ASSERT(pMessage->m_dwSize == 0);
		pMessage->m_dwSize = 0;
	}
	
	DWORD dwSize = pMessage->m_dwSize;													//copy size because function Convert() will change m_dwSize variable
	
	pMessage->Convert(true);															//convert header to network order

    if (send(socket, pMessage->m_chId, pMessage->GetHeaderSize(), 0) == SOCKET_ERROR)	//send message header
    {
		s.Format(L"header send() failed: error %d.\n", WSAGetLastError());
		AddLogLine(s);
		return E_FAIL;
	}

	if (dwSize)
	{
		if (send(socket, pMessage->m_pBody, dwSize, 0) == SOCKET_ERROR)					//send data
		{
			s.Format(L"data send() failed: error %d.\n", WSAGetLastError());
			AddLogLine(s);
			return E_FAIL;
		}
		s.Format(L"Sent %d kBytes\n", dwSize / 1024);
		AddLogLine(s);
	}

	return S_OK;
}

HRESULT CNetStreamingReceiver::SendHTTPMessage(SOCKET socket, CString sHTTP)
{
	if (!socket || sHTTP.IsEmpty())
	{
		ASSERT(false);
		return E_INVALIDARG;
	}

	long	nTextLength	= sHTTP.GetLength();
	char*	pCharBuffer = (char*)calloc(nTextLength, SIZE_C);

	if (!pCharBuffer)
	{
		return E_OUTOFMEMORY;
	}

	for (long n=0; n < nTextLength; ++n)
	{
		pCharBuffer[n] = (char)sHTTP[n];
	}

    if (send(socket, pCharBuffer, nTextLength, 0) == SOCKET_ERROR)	//send message header
    {
		CString s;
		s.Format(L"header send() failed: error %d.\n", WSAGetLastError());
		AddLogLine(s);
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CNetStreamingReceiver::ReceiveNetStreamingMessage(SOCKET socket, CAcqMessage* pMessage)
{
	int		error			= 0;
	int		nRetval			= 0;
	DWORD	nBytesReceived	= 0;
	CString s;

	if (!socket || !pMessage)
	{
		return E_INVALIDARG;
	}

	if ((nRetval = recv(socket, (char*)&pMessage->m_chId, pMessage->GetHeaderSize(), 0)) == SOCKET_ERROR)	//read header
	{
		s.Format(L"header receive() failed: error %d.\n", WSAGetLastError());
		AddLogLine(s);
		return E_FAIL;
	}

	if (nRetval == 0)
	{
		AddLogLine(L"Server/Client closed connection\n");
		return E_FAIL;
	}

	pMessage->Convert(false);		//convert Network byte order to host byte order (Big-Endian -> Little-Endian)

	if (!pMessage->IsValid())
	{
		AddLogLine(L"ERROR: Received invalid message.");
		return E_FAIL; //received invalid message
	}

	if (pMessage->m_dwSize > 0)		//read body (if any)
	{
		if (pMessage->m_pBody)
		{
			free(pMessage->m_pBody);
			pMessage->m_pBody = NULL;
		}

		ASSERT(pMessage->m_dwSize < 10 * 1024 * 1024); //we don't really expect more than 10 MB of data per block

		if (!(pMessage->m_pBody = (char*)calloc(pMessage->m_dwSize, SIZE_C)))
		{
			return E_OUTOFMEMORY;
		}
		
		nBytesReceived = 0;
		while (nBytesReceived < pMessage->m_dwSize)
		{
			if ((nRetval = recv(socket, (char*)pMessage->m_pBody + nBytesReceived, pMessage->m_dwSize - nBytesReceived, 0)) == SOCKET_ERROR)
			{
				s.Format(L"body receive() failed: error %d.\n", WSAGetLastError());
				AddLogLine(s);
				return E_FAIL;
			}

			nBytesReceived += nRetval;

			if (nRetval == 0)
			{
				AddLogLine(L"Server/Client closed connection\n");
				return E_FAIL;
			}
		}

		if (nBytesReceived < 1024)
		{
			s.Format(L"Received %d Bytes\n", nBytesReceived);
		}
		else
		{
			s.Format(L"Received %d kBytes\n", nBytesReceived / 1024);
		}

		AddLogLine(s);

		if (nBytesReceived != pMessage->m_dwSize)
		{
			AddLogLine(L"ERROR: Didn't receive as much as expected. (maybe connection got closed)");
			return E_FAIL;
		}
	}

	return S_OK;
}

HRESULT CNetStreamingReceiver::HandleMessage(CAcqMessage* pMessage, SOCKET nSocketReply)
{
	HRESULT		hr				= S_OK;
	bool		bMessageHandled	= false;
	CString		s;

	if (!pMessage)
	{
		return E_INVALIDARG;
	}

//handle CTRL packet
	if (pMessage->IsCtrlPacket())	
	{
		s.Format(L"Control Packet: code=%d, request=%d\n", pMessage->m_wCode, pMessage->m_wRequest);
		AddLogLine(s);
		switch (pMessage->m_wCode)
		{
			case CTRL_FromServer:
				switch (pMessage->m_wRequest)
				{
					case Server_AcquisitionStart:
						AddLogLine(L"From Server: Start Acquisition\n");
						m_bBasicInfoValid	= false;
						bMessageHandled		= true;
						break;
					case Server_AcquisitionStop:
						AddLogLine(L"From Server: Stop Acquisition\nPress \"Disconnect\", then \"Connect\" to continue receiving data.");
						m_bBasicInfoValid	= false;
						bMessageHandled		= true;
						break;
					case Server_ImpedanceStart:
						AddLogLine(L"From Server: Start Impedance\n");
						bMessageHandled		= true;	
						break;
					case Server_ImpedanceStop:
						AddLogLine(L"From Server: Stop Impedance\n");
						bMessageHandled		= true;
						break;
					case Server_RecordingStart:
						AddLogLine(L"From Server: Start Recording\n");
						bMessageHandled		= true;
						break;
					case Server_RecordingStop:
						AddLogLine(L"From Server: Stop Recording\n");
						bMessageHandled		= true;
						break;
					default:
						ASSERT(false);
						break;
				}
				break;

			case CTRL_FromClient:
				//not available in this demo
				break;

			default:
				break;
		}
	}
//handle DATA packet
	else if (pMessage->IsDataPacket())
	{
		s.Format(L"Data Packet: code=%d, request=%d\n", pMessage->m_wCode, pMessage->m_wRequest);
		AddLogLine(s);
		switch (pMessage->m_wCode)
		{
			case DATA_Info:
				switch (pMessage->m_wRequest)
				{
					case InfoType_Version:
						{
							if (pMessage->m_pBody && pMessage->m_dwSize == sizeof(m_nNetStreamingVersion))
							{
								memcpy((void*)&m_nNetStreamingVersion, pMessage->m_pBody, sizeof(m_nNetStreamingVersion));
								bMessageHandled		= true;
							}					
							else
							{
								m_nNetStreamingVersion = -1;
								ASSERT(false);
							}
						}
						break;

					case InfoType_BasicInfoAcq:
						{
							BasicInfoAcq* pInfo = (BasicInfoAcq*)pMessage->m_pBody;
							if (pInfo->dwSize == sizeof(BasicInfoAcq))
							{
								memcpy((void*)&m_BasicInfo, pMessage->m_pBody, sizeof(m_BasicInfo));
								m_bBasicInfoValid	=	(m_BasicInfo.nEegChan > 0 && m_BasicInfo.nEegChan < MAX_CHANNELS && m_BasicInfo.nRate > 0) ||
														(m_BasicInfo.nEegChan == -1 && m_BasicInfo.nRate == -1);	//if values are -1, the amplifier is not connected yet
								bMessageHandled		= true;
							}					
							else
							{
								ASSERT(false);
							}
						}
						break;

					case InfoType_ChannelInfo:
						{
							if (pMessage->m_dwSize > 0 && pMessage->m_dwSize % sizeof(NetStreamingChannelInfo) == 0)
							{
								if (m_pChannelInfoList)
								{
									free((void*)m_pChannelInfoList);
									m_pChannelInfoList = NULL;
								}
								
								m_nChannelInfoListSize = 0;
								if ((m_pChannelInfoList = (NetStreamingChannelInfo*)malloc(pMessage->m_dwSize)))
								{
									memcpy((void*)m_pChannelInfoList, pMessage->m_pBody, pMessage->m_dwSize);
									m_nChannelInfoListSize	= pMessage->m_dwSize;
									bMessageHandled			= true;
								}
								else
								{
									hr = E_OUTOFMEMORY;
									ASSERT(false);
								}
							}					
							else
							{
								ASSERT(false);
							}
						}
						break;

					case InfoType_StatusAmp:
						{
							if (pMessage->m_pBody && pMessage->m_dwSize == sizeof(m_nServerAmpStatus))
							{
								memcpy((void*)&m_nServerAmpStatus, pMessage->m_pBody, sizeof(m_nServerAmpStatus));
								bMessageHandled			= true;
							}					
							else
							{
								ASSERT(false);
							}
						}
							break;

					case InfoType_Time:
						{
							if (pMessage->m_pBody && pMessage->m_dwSize == sizeof(m_dTimePackageReceived))
							{
								memcpy((void*)&m_dTimePackageReceived, pMessage->m_pBody, sizeof(m_dTimePackageReceived));
								bMessageHandled		= true;
							}					
							else
							{
								m_dTimePackageReceived = 0;
								ASSERT(false);
							}
						}
						break;

					default:
						ASSERT(false); //unexpected request
						break;
				}
				break;

			case DATA_Eeg:
				switch (pMessage->m_wRequest)
				{
					case DataTypeFloat32bit:
						if (pMessage->m_dwSize > 0 && pMessage->m_pBody && pMessage->m_dwSize % SIZE_F == 0)
						{
							//pass it to amp
							DataReady((float*)pMessage->m_pBody, pMessage->m_dwSize, pMessage->m_unSample);
							bMessageHandled = true;
						}
						break;

					case DataTypeFloat32bitZIP:
						if (pMessage->m_dwSize > 0 && pMessage->m_dwSizeUncompressed > 0 && pMessage->m_pBody)
						{
							AddLogLine(L"ERROR: compressed data cannot be handled in this demo. Set the server to send uncompressed data");
							bMessageHandled = true;
						}
						break;

					default:
						AddLogLine(L"ERROR: data format cannot be handled in this demo");
						break;
				}
				break;

			case DATA_Events:
				switch (pMessage->m_wRequest)
				{
					case DataTypeEventList:
						if (pMessage->m_dwSize > 0 && pMessage->m_pBody && pMessage->m_dwSize % sizeof(NetStreamingEvent) == 0)
						{
							//pass it to amp
							EventDataReady((NetStreamingEvent*)pMessage->m_pBody, pMessage->m_dwSize);
							bMessageHandled = true;
						}
						break;
					default:
						ASSERT(false);
						break;
				}
				break;

			case DATA_Impedances:
				switch (pMessage->m_wRequest)
				{
					case DataTypeFloat32bit:
						if (pMessage->m_dwSize > 0 && pMessage->m_pBody && pMessage->m_dwSize % SIZE_F == 0)
						{
							//pass it to amp
							ImpedanceDataReady((float*)pMessage->m_pBody, pMessage->m_dwSize);
							bMessageHandled = true;
						}
						break;
					default:
						ASSERT(false);
						break;
				}
				break;

			default:
				ASSERT(false);
				break;
		}
	}

	if (!bMessageHandled)
	{
		AddLogLine(L"ERROR: Received unknown message.");
	}

	hr = (SUCCEEDED(hr) && !bMessageHandled) ? E_FAIL : hr;

	return hr;
}

//client methods

//requests and receives newtview version from server
//returns S_OK when netstreaming server version matches the client version
HRESULT CNetStreamingReceiver::ClientCheckNetStreamingVersion()
{
	CString s;

	if (!m_bClientInited)
	{
		return E_FAIL;
	}

	m_nNetStreamingVersion = -1;

	//send basic info request to server
	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, Request_Version);
	if (FAILED(SendNetStreamingMessage(m_SocketClient, &message)))
	{
		return E_FAIL;
	}

	//receive some packets, hoping the server will reply
	long nCounter = 0;
	while (m_nNetStreamingVersion == -1 && nCounter < 10)
	{
		Sleep(50);
		if (FAILED(ListenClient(1, NULL)))
		{
			AddLogLine(L"Failed to recieve NetStreaming Version.");
			return E_FAIL;
		}
		nCounter++;
	}

	if (m_nNetStreamingVersion != -1 && m_nNetStreamingVersion != NETSTREAM_VERSION)
	{
		
		s.Format(L"ERROR: The NetStreaming server is running NetStreaming version %d while NetStreaming version %d was expected. (make sure Server and Client run compatible versions of NetStreaming)", m_nNetStreamingVersion, NETSTREAM_VERSION);
		AddLogLine(s);
	}
	else if (m_nNetStreamingVersion == -1)
	{
		AddLogLine(L"ERROR: The NetStreaming server did not answer in time. (make sure client and server are correctly configured)");
	}
	else
	{
		s.Format(L"Server NetStreaming Version: %d", m_nNetStreamingVersion);
		AddLogLine(s,1);
	}
	
	return (m_nNetStreamingVersion == NETSTREAM_VERSION) ? S_OK : E_FAIL;
}

//requests and receives basic information about the acquisition from server
HRESULT CNetStreamingReceiver::ClientGetBasicInfo(BasicInfoAcq* pnBasicInfo)
{
	if (!pnBasicInfo)
	{
		return E_INVALIDARG;
	}

	if (!m_bClientInited)
	{
		return E_FAIL;
	}

	m_bBasicInfoValid = false;

	//send basic info request to server
	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, Request_BasicInfoAcq);
	if (FAILED(SendNetStreamingMessage(m_SocketClient, &message)))
	{
		ASSERT(false);
		return E_FAIL;
	}

	//receive some packets, hoping the server will reply
	long nCounter = 0;
	while (!m_bBasicInfoValid && nCounter < 10)
	{
		Sleep(50);
		if (FAILED(ListenClient(1, NULL)))
		{
			AddLogLine(L"Failed to recieve NetStreaming Version.");
			return E_FAIL;
		}
		nCounter++;
	}
	
	if (m_bBasicInfoValid)
	{
		//copy basicinfo
		memcpy(pnBasicInfo, (BasicInfoAcq*)&m_BasicInfo, sizeof(*pnBasicInfo)); //should be safe to cast away the volatile here, but still ugly
		return S_OK;
	}

	return E_FAIL;
}

//requests and receives specific channel information from server
HRESULT CNetStreamingReceiver::ClientGetChannelInfoList(NetStreamingChannelInfo* pChannelInfoList, long nSize)
{
	if (!pChannelInfoList || nSize <= 0)
	{
		return E_INVALIDARG;
	}

	if (!m_bClientInited)
	{
		return E_FAIL;
	}

	if (m_pChannelInfoList)
	{
		free((void*)m_pChannelInfoList);
		m_pChannelInfoList = NULL;
	}
	m_nChannelInfoListSize = 0;

	//send label request to server
	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, Request_ChannelInfo);
	
	if (FAILED(SendNetStreamingMessage(m_SocketClient, &message)))
	{
		ASSERT(false);
		return E_FAIL;
	}

	//receive some packets, hoping the server will reply
	long nCounter = 0;
	while (m_nChannelInfoListSize != nSize && nCounter < 10)
	{
		Sleep(50);
		if (FAILED(ListenClient(1, NULL)))
		{
			AddLogLine(L"Failed to recieve NetStreaming Version.");
			return E_FAIL;
		}
		nCounter++;
	}
	
	if (m_pChannelInfoList && m_nChannelInfoListSize == nSize)
	{
		//copy channel info list
		memcpy(pChannelInfoList, (NetStreamingChannelInfo*)m_pChannelInfoList, nSize); //should be save to cast away the volatile here, but it's still ugly
		return S_OK;
	}

	return E_FAIL;
}

//get info from server whether amplifier is currently connected or unconnected
HRESULT	CNetStreamingReceiver::ClientGetServerAmpStatus(long* pnAmpStatus)
{
	if (!pnAmpStatus)
	{
		return E_INVALIDARG;
	}

	if (!m_bClientInited)
	{
		return E_FAIL;
	}

	m_nServerAmpStatus = -1;

	//send basic info request to server
	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, Request_StatusAmp);
	if (FAILED(SendNetStreamingMessage(m_SocketClient, &message)))
	{
		ASSERT(false);
		return E_FAIL;
	}

	//receive some packets, hoping the server will reply in time
	long nCounter = 0;
	while (nCounter < 10)
	{
		Sleep(50);
		if (FAILED(ListenClient(1, NULL)))
		{
			AddLogLine(L"Failed to recieve amplifier status.");
			return E_FAIL;
		}

		if (m_nServerAmpStatus != -1)
		{
			break;
		}

		nCounter++;
	}
	
	*pnAmpStatus = m_nServerAmpStatus;

	return m_nServerAmpStatus > -1 ? S_OK : E_FAIL;
}

//asks the server to start/stop sending datablocks (waveforms, events, impedances)
HRESULT CNetStreamingReceiver::ClientRequestStreamData(bool bStartStreaming)
{
	if (!m_bClientInited)
	{
		return E_FAIL;
	}

	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, bStartStreaming ? Request_StreamingStart : Request_StreamingStop);
	return SendNetStreamingMessage(m_SocketClient, &message);
}

//asks the server to use a specific file path for the next recordging (needs to be allowed by the server)
HRESULT CNetStreamingReceiver::ClientRequestSetRecPath(CString sRecPath)
{
	if (!m_bClientInited || sRecPath.IsEmpty() ||sRecPath.GetLength() >= MAX_PATH)
	{
		return E_FAIL;
	}

	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, Request_SetRecPath);
	
	wchar_t pwTmp[MAX_PATH];
	swprintf_s(pwTmp, L"%s", sRecPath.GetString());		//copy CString to wchar_t array

	message.SetBody((char*)pwTmp, sizeof(pwTmp));		//set path in body
	
	return SendNetStreamingMessage(m_SocketClient, &message);
}

//asks server to start or stop amplifier (needs to be allowed by server)
HRESULT CNetStreamingReceiver::ClientRequestControlAmp(bool bStart)
{
	if (!m_bClientInited)
	{
		return E_FAIL;
	}

	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, bStart ? Request_AmpConnect : Request_AmpDisconnect);
	return SendNetStreamingMessage(m_SocketClient, &message);
}

//asks server to start or stop recording (needs to be allowed by server)
HRESULT CNetStreamingReceiver::ClientRequestControlRecording(bool bStart)
{
	if (!m_bClientInited)
	{
		return E_FAIL;
	}

	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, bStart ? Request_RecordingStart : Request_RecordingStop);
	return SendNetStreamingMessage(m_SocketClient, &message);
}

//asks server to start or stop impedance test (needs to be allowed by server)
HRESULT CNetStreamingReceiver::ClientRequestControlImpedanceTest(bool bStart)
{
	if (!m_bClientInited)
	{
		return E_FAIL;
	}

	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, bStart ? Request_ImpedanceStart : Request_ImpedanceStop);
	return SendNetStreamingMessage(m_SocketClient, &message);
}

//handles block of waveform data
HRESULT CNetStreamingReceiver::DataReady(float* pfData, unsigned long unSize, unsigned long unBlockStartSample)
{
	HRESULT		hr = E_FAIL;
	CString		s;

	long		nNumSamples;


	if (m_BasicInfo.nEegChan <= 0)
	{
		AddLogLine(L"ERROR: number of channels is 0");
		return E_FAIL;
	}

	if (!pfData || unSize == 0 || 
		unSize % SIZE_F != 0 ||
		(unSize / SIZE_F) % m_BasicInfo.nEegChan != 0)
	{
		AddLogLine(L"ERROR: data block has an invalid size");
		return E_INVALIDARG;
	}

	nNumSamples = (unSize / SIZE_F) / m_BasicInfo.nEegChan;

	if (nNumSamples <= 0)
	{
		AddLogLine(L"ERROR: no samples in data block");
		return E_FAIL;
	}

	s.Format(L"Received Data (StartSample: %d, %d samples)", unBlockStartSample, nNumSamples);
	AddLogLine(s);

	if (m_pCtrlWaveforms)
	{
		m_pCtrlWaveforms->NewDataBlock(pfData, m_BasicInfo.nEegChan, nNumSamples);
	}

	return S_OK;
}

//handles block of impedance data
HRESULT CNetStreamingReceiver::ImpedanceDataReady(float* pfData, unsigned long unSize)
{
	if (m_BasicInfo.nEegChan <= 0)
	{
		AddLogLine(L"ERROR: number of channels is 0");
		return E_FAIL;
	}

	if (!pfData || unSize == 0 || unSize % SIZE_F != 0 || 
		(unSize / SIZE_F) % m_BasicInfo.nEegChan != 0 || 
		(unSize / SIZE_F) / m_BasicInfo.nEegChan != 1)
	{
		AddLogLine(L"ERROR: data block has an invalid size");
		return E_INVALIDARG;
	}

	CString sTmp;
	float	fImp;
	CString s = L"Impedances (kOhm): ";
	for (unsigned long n = 0; n < (unSize / SIZE_F); ++n)
	{
		fImp = pfData[n] / 1000.0f;
		sTmp.Format(L"%d: %.1f\t", n+1,   fImp < 0.0f	? 0.0f 
										: fImp > 250.0f	? 250.0f 
										: fImp);
		s.Append(sTmp);
	}
	AddLogLine(s,1);

	return S_OK;
}

//handles block of event data
HRESULT CNetStreamingReceiver::EventDataReady(NetStreamingEvent* pEventData, unsigned long unSize)
{
	if (!pEventData || unSize == 0 || unSize % sizeof(NetStreamingEvent) != 0)
	{
		return E_INVALIDARG;
	}

	CString s;

	for (unsigned long n=0; n < unSize / sizeof(NetStreamingEvent); ++n)
	{
		if (wcslen(pEventData[n].wcEventAnnotation) > 0)
		{
			s.Format(L"Event: %d (%s)\t sample: %d\n", pEventData[n].nEventType, pEventData[n].wcEventAnnotation, pEventData[n].nEventStart);
		}
		else
		{
			s.Format(L"Event: %d\t sample: %d\n", pEventData[n].nEventType, pEventData[n].nEventStart);
		}
		
		AddLogLine(s,2);
	}

	return S_OK;
}

HRESULT CNetStreamingReceiver::ClientGetDelay(double* pdDelayMS)
{
	double dTimeTmp1, dTimeTmp2;

	if (!m_bClientInited || !pdDelayMS)
	{
		return E_FAIL;
	}

	m_dTimePackageReceived	= 0;
	
	//send basic info request to server
	CAcqMessage message(NETSTREAM_CTRL, CTRL_FromClient, Request_Delay);
	if (FAILED(SendNetStreamingMessage(m_SocketClient, &message)))
	{
		ASSERT(false);
		return E_FAIL;
	}

	//measure time it takes to receive an answer
	get_clock(&dTimeTmp1);
	dTimeTmp2 = dTimeTmp1;

	//wait 2sec for answer
	while (m_dTimePackageReceived == 0 && (dTimeTmp2 - dTimeTmp1) < 2)
	{
		if (FAILED(ListenClient(1, NULL)))
		{
			AddLogLine(L"Failed to recieve NetStreaming Version.");
			return E_FAIL;
		}
		get_clock(&dTimeTmp2);
	}

	*pdDelayMS = (dTimeTmp2 - dTimeTmp1) * 1000.0;

	return S_OK;
}

//run client listener in a thread
void CListenThread::threadCall()
{
	if (!m_pNetStreaming || !m_bActive)
	{	
		ATLASSERT(FALSE);
		return;
	}

	m_pNetStreaming->ListenClient(-1, &m_bActive);
	m_pNetStreaming->CloseClient();

	m_bActive = false;
}