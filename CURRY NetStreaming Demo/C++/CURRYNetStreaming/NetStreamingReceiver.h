/****************************************************************************
 * (c) Neuroscan $Date: 2020-05-14 15:50:41 +0200 (Thu, 14 May 2020) $
 *
 * $Revision: 23937 $
 * $Author: tech $
 **************************************************(header generated by SVN)*/
// $NoKeywords: $

#pragma once

#include <cstdio>
#include <thread>
#include <atomic>

#include "Packets.h"

//****************************************************************************
//a simple thread wrapper
class CNetStreamingReceiver;
class CListenThread 
{
public:
    CListenThread(CNetStreamingReceiver* pNetStreaming)	{ m_bActive	= false; m_pNetStreaming = pNetStreaming; };
    void Start()										{ m_bActive	= true; std::thread Thread(&CListenThread::threadCall, this); Thread.detach(); }
    void End()											{ m_bActive = false; }

private:
	void					threadCall();

	std::atomic<bool>		m_bActive;
	CNetStreamingReceiver*	m_pNetStreaming;	//not fully thread safe, handle with care!
};
//****************************************************************************



//****************************************************************************
//this class communicates with a CURRY NetStreaming server
class CNetStreamingReceiver
{
public:
	CNetStreamingReceiver(IAddLogLine* pAddLogLine, ICtrlWaveforms* pCtrlWavelforms);
	~CNetStreamingReceiver(void);

	void		SetClient(bool bConnect, CString sIP = L"", long nPort = 0);
	bool		IsConnected();
	
	HRESULT		OpenClient(CString* psError);
	BOOL		StartClientThread();
	HRESULT		CloseClient();

	HRESULT		ClientCheckNetStreamingVersion();
	HRESULT		ClientGetBasicInfo(BasicInfoAcq* pnBasicInfo);
	HRESULT		ClientGetChannelInfoList(NetStreamingChannelInfo* pChannelInfoList, long nSize);
	HRESULT		ClientGetServerAmpStatus(long* pnAmpStatus);

	HRESULT		ClientRequestStreamData(bool bStartStreaming);
	HRESULT		ClientRequestSetRecPath(CString sRecPath);
	HRESULT		ClientRequestControlAmp(bool bStart);
	HRESULT		ClientRequestControlRecording(bool bStart);
	HRESULT		ClientRequestControlImpedanceTest(bool bStart);
	HRESULT		ClientGetDelay(double* pdDelayMS);

	bool		ClientIsInited() {return m_bClientInited;}
	bool		ClientIsReceivingData() {return m_bBasicInfoValid;}

	HRESULT		ListenClient(long nNumReceiveMessages, std::atomic<bool>* pbActive);

protected:
	void		AddLogLine(CString sLogLine, long nLogID = 0);

	HRESULT		SendNetStreamingMessage(SOCKET socket, CAcqMessage* pMessage);
	HRESULT		ReceiveNetStreamingMessage(SOCKET socket, CAcqMessage* pMessage);
	HRESULT		HandleMessage(CAcqMessage* pMessage, SOCKET nSocketReply);
	HRESULT		SendHTTPMessage(SOCKET socket, CString sHTTP);

	//data block handlers
	HRESULT		DataReady(float* pfData, unsigned long unSize, unsigned long unBlockStartSample);
	HRESULT		ImpedanceDataReady(float* pfData, unsigned long unSize);
	HRESULT		EventDataReady(NetStreamingEvent* pEventData, unsigned long unSize);

	long								m_nSocketType;

	bool								m_bDoConnect;
	unsigned short						m_usNetstreamPort;
	CString								m_sNetstreamClientServerIP;

	IAddLogLine*						m_pAddLogLine;
	ICtrlWaveforms*						m_pCtrlWaveforms;

	SOCKET								m_SocketClient;
	bool								m_bClientInited;

	volatile long						m_nNetStreamingVersion;

	volatile BasicInfoAcq				m_BasicInfo;
	volatile bool						m_bBasicInfoValid;
	volatile long						m_nServerAmpStatus;

	volatile NetStreamingChannelInfo*	m_pChannelInfoList;
	volatile long						m_nChannelInfoListSize;

	volatile double						m_dTimePackageReceived;

	CListenThread						m_Thread;
};
//****************************************************************************